<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/simple.css">

    <link rel="stylesheet" href="plugin/highlight/zenburn.css">
</head>
<body>
<div class="reveal">
    <div class="footer"><a href="http://twitter.com/pivovarit">@pivovarit</a></div>

    <div class="slides">
        <section>
            <h2>Dancing with Uncertainty</h2>
            <h4>Challenges of Distributed Systems</h4>
            <br><br>
            <h4><a href="https://pivovarit.github.io"> Grzegorz Piwowarek</a></h4>
            <h5><a href="https://twitter.com/pivovarit">@pivovarit</a></h5>
        </section>

        <section>
            <h2>{ <a href="https://4comprehension.com/">4comprehension.com</a> }</h2>
            <h4>WarsawJUG | Vavr | Oracle ACE</h4>
            <h4>Independent Consultant/Trainer</h4>
            <small>distributed systems | microservices | async | reactive | java</small>
            <h5><a href="https://twitter.com/pivovarit">@pivovarit</a></h5>
            <br>
        </section>

        <section>
            <h2>CAP Theorem</h2>
            <ul>
                <li><strong>C</strong>onsistency</li>
                <li><strong>A</strong>vailability</li>
                <li><strong>P</strong>artition tolerance</li>
            </ul>
        </section>

        <section>
            <h2>Consistency</h2>
            <h5>every read receives the most recent write</h5>
            <small>(a single-copy illusion)</small>
        </section>

        <section>
            <h2>Availability</h2>
            <h5>every request receives a non-error response</h5>
            <small>(even if some nodes are down)</small>
        </section>

        <section>
            <h2>Partition tolerance</h2>
            <h5>system continues to operate even if network links are lost</h5>
        </section>

        <section>
            <h2>What makes systems...distributed?</h2>
        </section>

        <section>
            <h4>distributed systems are systems that communicate over unreliable channels</h4>
        </section>

        <section>
            <h4>Network is unreliable</h4>
            <small><small>as of 2025</small></small>
            <br>
            <img src="img/sharks.jpg" width="40%"/>

            <small><small><a href="https://slate.com/technology/2014/08/shark-attacks-threaten-google-s-undersea-internet-cables-video.html">https://slate.com/technology/2014/08/shark-attacks-threaten-google-s-undersea-internet-cables-video.html</a></small></small>
        </section>

        <section>
            <img src="img/packet-loss.jpeg" width="40%"/>
            <br>
            <small><small><a href="https://en.wikipedia.org/wiki/IP_over_Avian_Carriers">https://en.wikipedia.org/wiki/IP_over_Avian_Carriers</a></small></small>
        </section>

        <section>
            <p><strong>Rule:</strong> In the presence of a network partition, a distributed system must choose either
                <em>Consistency</em> or <em>Availability</em>.</p>
        </section>

        <section>
            <h2>The Two Generals Problem</h2>
        </section>

        <section>
            <h3>The Scenario</h3>
            <p>Two generals are planning to attack a city. They can only communicate via messengers, who may be captured.</p>

            <div class="fragment">
                <p>
                    How can both generals be sure they attack at the same time, given that messages might not arrive?
                </p>
            </div>
        </section>

        <section>
            <p>
                There is <strong>no deterministic way</strong> for two parties to <strong>coordinate</strong> over an unreliable communication channel.
            </p>
        </section>

        <section>
            <h3>...</h3>
        </section>

        <section>
            <img src="img/snake.jpg" width="70%"/>
        </section>

        <section data-transition="fade">
            <img src="img/microservices.jpeg" width="80%"/>
            <small><small><a href="https://twitter.com/ddprrt/status/1425418538257428488">https://twitter.com/ddprrt/status/1425418538257428488</a></small></small>
        </section>

        <section data-transition="fade">
            <img src="img/microservices-2.jpeg" width="80%"/>
            <small><small><a href="https://twitter.com/ddprrt/status/1425418538257428488">https://twitter.com/ddprrt/status/1425418538257428488</a></small></small>
        </section>

        <section>
            <img src="img/hoare.jpg" width="30%"/>
            <blockquote
                    cite="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">
                "It was the invention of the null reference in 1965...I call it my billion-dollar mistake."
            </blockquote>
            <small><small>Tony Hoare</small></small>
        </section>

        <section>
            <img src="img/future-null.jpg" width="60%"/>
        </section>


        <section data-transition="fade">
            <h4>Another <em>"billion-dollar mistake":</em></h4>
            <h3 class="fragment">Microservices</h3>
        </section>

        <section data-transition="fade">
            <h4>Another <em>"billion-dollar mistake":</em></h4>
            <h3>"Micro"</h3>
        </section>

        <section data-transition="fade">
            <h4 class="fragment">Microservice vs service?</h4>
            <h4 class="fragment">How small is "micro"?</h4>
            <h5 class="fragment">N lines of code?</h5>
            <h5 class="fragment">N endpoints?</h5>
            <h5 class="fragment">N classes?</h5>
            <h5 class="fragment">N MBs?</h5>
            <h5 class="fragment">N responsibilities?</h5>
            <h5 class="fragment">Rewritable in X time?</h5>
        </section>

        <section>
            <h4>Microservices: the Main Idea</h4>
            <h3 class="fragment">Enable scalability through independence and modularity</h3>
        </section>

        <section data-transition="fade">
            <h4>Tight coupling - Low cohesion</h4>

            <img src="img/tight-coupling.png" width="50%"/>
            <br>
            <small><small>source: <a href="https://enterprisecraftsmanship.com/posts/cohesion-coupling-difference/">https://enterprisecraftsmanship.com/posts/cohesion-coupling-difference/</a></small></small>
        </section>
        <section data-transition="fade">
            <h4>Low coupling - High cohesion</h4>

            <img src="img/loose-coupling.png" width="50%"/>
            <br>
            <small><small>source: <a href="https://enterprisecraftsmanship.com/posts/cohesion-coupling-difference/">https://enterprisecraftsmanship.com/posts/cohesion-coupling-difference/</a></small></small>
        </section>

        <section>
            <h4>You can have modularity without microservices</h4>
            <img class="fragment" src="img/modular.png" width="50%"/>
            <small class="fragment">Naturally, you don't get all the benefits, but it's not a demanding
                investment</small>
        </section>

        <section>
            <img src="img/evolution.png" width="70%"/>
        </section>

        <section>
            <blockquote cite="Building Microservices by Sam Newman">
                "The smaller the service, the more you maximize the benefits and downsides of microservice
                architecture."
            </blockquote>
            <small>Sam Newman</small>
        </section>

        <section>
            <img src="img/netflix.png" width="70%"/>
            <br>
            <small>author: Bruce Wong</small>
            <h3 class="fragment">Netflix: 2000 engineers</h3>
        </section>

        <section>
            <img src="img/boat.png" width="50%"/>
        </section>

        <section>
            <blockquote cite="'How Netflix Really Uses Java' by Paul Bakker" width="100%">
                However, don't be fooled by the size of those microservices, because a lot of those so-called
                microservices at Netflix are a lot larger, just looking at the code base, than the big monoliths that
                I've worked at, at many other companies.
            </blockquote>
            <small>Paul Bakker</small>
            <br>
            <small><small>source: <a href="https://www.infoq.com/presentations/netflix-java/">https://www.infoq.com/presentations/netflix-java/</a></small></small>
        </section>

        <section>
            <h5>Do not ask about the max size, but when to split</h5>
        </section>

        <section>
            <h5>So... when do we split?</h5>
            <br>
            <h5 class="fragment">When it hurts too much</h5>
            <h5 class="fragment">The #1 rule of distributed systems: don't do it until you have to</h5>
        </section>

        <section>
            <img src="img/micro-monolith.jpg" width="70%"/>
        </section>


        <section>
            <h3>The Pragmatic Default</h3>
            <img src="img/citadel.png" width="60%"/>
            <br>
            <small> <small><a href="https://twitter.com/dhh/status/1247522358908215296</small">https://twitter.com/dhh/status/1247522358908215296</a></small></small>
        </section>

        <section>
            <blockquote cite="'Static Analysis at Scale: An Instagram Story' by Benjamin Woodruff" width="100%">
                Our server app is a monolith, one big codebase of several million lines and a few thousand Django
                endpoints [1], all loaded up and served together. A few services have been split out of the monolith,
                but we don‚Äôt have any plans to aggressively break it up.
            </blockquote>
            <small><small><a
                    href="https://instagram-engineering.com/static-analysis-at-scale-an-instagram-story-8f498ab71a0c">https://instagram-engineering.com/static-analysis-at-scale-an-instagram-story-8f498ab71a0c</a></small></small>
        </section>

        <section>
            <h4>Reliability in an unreliable world</h4>
        </section>

        <section>
            <h4>When sending a message over unreliable channels, how to guarantee delivery?</h4>
        </section>

        <section>
            <h4>(...thought experiment...)</h4>
        </section>

        <section>
            <h3>Definition</h3>
            <p>An operation is <strong>idempotent</strong> if performing it multiple times produces the <em>same
                effect</em> as performing it once.</p>
            <br>
            <pre><code>f(f(x)) = f(x)</code></pre>
        </section>

        <section>
            <h3>Examples</h3>
            <ul>
                <li>Setting a user‚Äôs status to ‚Äúactive‚Äù ‚Üí ‚úÖ</li>
                <li>Incrementing a counter ‚Üí ‚ùå</li>
            </ul>
        </section>

        <section>
            <h3>In a distributed system</h3>
            <p>Failures and retries are inevitable.</p>
        </section>

        <section>
            <ul>
                <li>Network retries may cause duplicate requests</li>
                <li>Clients or load balancers might resend operations</li>
                <li>Idempotency prevents unwanted side effects</li>
            </ul>
        </section>


        <section>
            <h3>Exactly-once delivery?</h3>
            <p><strong>A fairy tale.</strong></p>
            <br><br>
            <div class="fragment">
                <p><strong>Reality:</strong> You only ever get:</p>
                <ul>
                    <li><strong>at-most-once</strong> ‚Üí messages may be lost</li>
                    <li><strong>at-least-once</strong> ‚Üí messages may be duplicated</li>
                </ul>
            </div>
        </section>

        <section>
            <h3>Exactly-once doesn‚Äôt exist</h3>
            <ul>
                <li>Networks can fail between <em>send</em> and <em>acknowledge</em></li>
                <li>Clients can retry</li>
                <li>Servers can crash mid-processing</li>
            </ul>
        </section>

        <section>
            <h3>Exactly-once <em>effect</em></h3>
            <p>We can‚Äôt guarantee <em>exactly-once delivery</em>,</p>
            <p>but we can design for <strong>exactly-once effect</strong> using idempotency.</p>
            <br>
            <pre><code>at-least-once delivery + idempotency = exactly-once</code></pre>
        </section>

        <section>
            <h2>PACELC Theorem</h2>
            <p>
                Daniel Abadi extended CAP to include trade-offs <em>when no partition occurs</em>:
            </p>
            <blockquote>
                <strong>If P</strong> (partition) ‚Üí <em>A</em> or <em>C</em><br>
                <strong>Else</strong> (ok) ‚Üí <em>Latency</em> or <em>Consistency</em>
            </blockquote>
        </section>

        <section>
            <p>Even without partitions, there‚Äôs another trade-off</p>
            <strong>Waiting for consensus takes time</strong>
            <br><br>
            <small><p>This is the ‚ÄúELC‚Äù part of PACELC.</p></small>
        </section>

        <section>
            <h3>Imagine two coffee shops sharing an order system</h3>
            <ul>
                <li>network failure</strong> ‚Üí choice:
                    <em>keep taking orders (A)</em> or <em>pause until synced (C)</em></li>
                <li>no failure</strong> ‚Üí each order can be:
                    <em>fast but maybe outdated (L)</em> or <em>slow but always accurate (C)</em></li>
            </ul>
        </section>

        <section>
            <h3>Real-world examples</h3>
            <ul>
                <li><strong>Amazon Dynamo / Cassandra</strong> ‚Üí prioritize <em>Availability + Low Latency</em></li>
                <li><strong>Google Spanner</strong> ‚Üí prioritize <em>Consistency</em>, accept more latency</li>
            </ul>
        </section>

        <section>
            <h3>temporal coupling</h3>
            <h4>when all your services need to responsive at the same time</h4>
        </section>

        <section>
            <h3>False Dichotomy:</h3>
            <h4>Consistent vs. Inconsistent</h4>
        </section>

        <section>
            <h3>Different consistency levels</h3>
            <ul>
                <li><strong>Strong consistency</strong> ‚Üí Data converges immediately</li>
                <li><strong>Eventual consistency</strong> ‚Üí Data converges... eventually</li>
                <li><strong>Accidental consistency</strong> ‚Üí Data converges... maybe</li>
            </ul>
            <p>All are ‚Äúconsistent‚Äù ‚Äî just in different ways.</p>
        </section>

        <section>
            <h3>Eventual consistency</h3>
            <blockquote>
                If no new updates occur, all replicas will <strong>eventually</strong> converge to the same state.
            </blockquote>
            <p>It‚Äôs a trade-off: we get <strong>availability and speed</strong> at the cost of temporary disagreement.
            </p>
        </section>

        <section>
            <h3>Why this makes sense</h3>
            <ul>
                <li>Networks are slow and unreliable</li>
                <li>Waiting for everyone to agree slows everything down</li>
                <li>So we let nodes respond now and sync later</li>
            </ul>
            <p>‚Üí <strong>Fast now, consistent later</strong></p>
        </section>

        <section data-transition="fade">
            <h3>synchronous communication</h3>
            <img src="img/sync1.png" width="80%"/>
        </section>

        <section data-transition="fade">
            <h3>asynchronous communication</h3>
            <img src="img/sync2.png" width="80%"/>
        </section>

        <section>
            <h3>From HTTP calls...</h3>
            <pre><code data-trim>
OrderService -> PaymentService -> NotificationService
    </code></pre>
            <p>Each service calls another directly...</p>
            <p><em>...tight coupling, dependencies, and failure chains.</em></p>
        </section>

        <section>
            <h3>...to Events</h3>
            <pre><code data-trim>
OrderService --> publishes OrderCreatedEvent
PaymentService --> consumes OrderCreatedEvent
NotificationService --> consumes PaymentConfirmedEvent
    </code></pre>
            <p>Services react to <strong>events</strong> instead of making direct calls.</p>
        </section>

        <section>
            <h2>Local Read Models</h2>
            <p>Each service maintains its own <strong>local view</strong> of data it needs.</p>
            <pre><code data-trim>
@EventListener
void on(PaymentConfirmedEvent event) {
    orderReadModel.updateStatus(event.orderId(), "PAID");
}
    </code></pre>
            <p>This enables fast, local reads - no cross-service queries needed</p>
            <p>...but it eventually consistent</p>

        </section>

        <section>
            <h3>Why Local Read Models?</h3>
            <ul>
                <li>No need to call other services for data</li>
                <li>Improves reliability - service can operate even if others are down</li>
            </ul>
        </section>


        <section>
            <h2>Time</h2>

            <img src="img/time.jpg" width="60%"/>
        </section>

        <section>
            <pre><code data-trim="" style="font-size: 0.8em;line-height: 0.9; max-height: 90%">
                   var first = Instant.now();
                   var second = Instant.now();
            </code></pre>

            <h3><code>first</code> <= <code>second?</code></h3>
        </section>

        <section>
            <p>A <strong>monotonic clock</strong> always moves forward - never backward.</p>
            <p>But most <code>system clocks</code> are <strong>not monotonic</strong>.</p>
        </section>

        <section>
            <h3>Why clocks go backwards</h3>
            <ul>
                <li><strong>NTP</strong> (Network Time Protocol) adjustment</li>
                <li>Virtual machines paused and resumed</li>
                <li>Leap seconds</li>
                <li>Manual time correction by an admin</li>
            </ul>
        </section>

        <section>
            <h3>Monotonic clocks to the rescue</h3>
            <ul>
                <li>In Java: <code>System.nanoTime()</code></li>
                <li>In Linux: <code>CLOCK_MONOTONIC</code></li>
            </ul>
            <p>They never go backward, but don‚Äôt represent ‚Äúreal‚Äù time.</p>

            <br>
            <small><a href="https://www.javaadvent.com/2019/12/measuring-time-from-java-to-kernel-and-back.html">Measuring time: from Java to kernel and back</a></small>

        </section>

        <section>
            <p>In distributed systems, time is‚Ä¶ <strong>an illusion</strong>.</p>
        </section>

        <section>
            <h3>The problem with clocks</h3>
            <ul>
                <li>Each machine has its own clock</li>
                <li>Clocks drift - even if synced</li>
                <li>Network delays make ‚Äúnow‚Äù ambiguous</li>
            </ul>
            <p>So: there is no single, global ‚Äúcurrent time.‚Äù</p>
        </section>

        <section>
            <h3>Example</h3>
            <p>Two servers record an event:</p>
            <ul>
                <li>Server A: event at 12:00:00.100</li>
                <li>Server B: event at 12:00:00.090</li>
            </ul>
            <p>Which happened first? ü§î</p>
        </section>

        <section>
            <h3>Why this matters</h3>
            <ul>
                <li>Event ordering affects state changes</li>
                <li>Conflicts appear when we can‚Äôt tell ‚Äúwhat came first‚Äù</li>
                <li>Replication, logs, and causality all depend on time</li>
            </ul>
        </section>

        <section>
            <h3>Happened-before relationship</h3>
            <p>Instead of wall-clock time, we use <strong>causal order</strong>:</p>
            <blockquote>
                A ‚Üí B if A happened before B (causally)
            </blockquote>
            <p>We care about <em>ordering</em> of events, not their timestamps.</p>
        </section>

        <section>
            <h3>Logical clocks</h3>
            <ul>
                <li><strong>Lamport clocks</strong> ‚Üí simple counters to track causal order</li>
                <li><strong>Vector clocks</strong> ‚Üí richer structure to detect concurrent events</li>
            </ul>
            <p>They don‚Äôt measure real time - they measure <strong>cause and effect</strong>.</p>
        </section>

        <section>
            <h3>Real time vs. logical time</h3>
            <ul>
                <li><strong>Real time</strong> ‚Üí what your watch shows</li>
                <li><strong>Logical time</strong> ‚Üí what the system can <em>prove</em> happened first</li>
            </ul>
            <p>Distributed systems live in <strong>logical time</strong>.</p>
        </section>

        <section>
            <p>Google‚Äôs Spanner uses special hardware clocks (TrueTime API) ‚è±Ô∏è</p>
            <p>But even then, they include an <strong>uncertainty window</strong> - because perfect time doesn‚Äôt exist.
            </p>
        </section>

        <section>
            <h3>Summary</h3>
            <ul>
                <li>Each node has its own imperfect sense of time</li>
                <li>We can‚Äôt rely on timestamps for ordering</li>
                <li>We use <strong>logical or causal time</strong> to reason safely</li>
            </ul>
            <p>Time is relative - especially in distributed systems üåå</p>
        </section>

        <section>
            <h5>Eventual Consistency != Accidental Consistency</h5>
        </section>

        <section data-transition="fade">
            <img src="img/dual-write.png" width="60%"/>
        </section>

        <section data-transition="fade">
            <img src="img/dual-write-2.png" width="60%"/>
        </section>

        <section>

            <pre><code class="hljs language-java" data-trim data-noescape>
                @Transactional
                public void createUser(CreateUserCommand command) {
                    var user = from(command);

                    persist(user);                     // 1
                    send(UserCreatedEvent.from(user)); // 2
                }
            </code></pre>
            <h4><code>@Transactional</code> won't save you in the distributed world</h4>
        </section>

        <section data-transition="fade">
            <h4>Dual-Write (distributed transaction)</h4>
            <img src="img/cdc3.png" width="50%"/>
        </section>

        <section data-transition="fade">
            <h4>Singe-Write with async propagation</h4>
            <img src="img/cdc4.png" width="50%"/>
        </section>

        <section>
            <h4>Transactional Outbox Pattern</h4>
            <h4>Change Data Capture</h4>
        </section>

        <section>
            <h2>Transactional Outbox Pattern</h2>
            <p>Write the event to a local <strong>outbox table</strong> as part of the same transaction.</p>
            <pre><code data-trim>
@Transactional
public void createOrder(Order order) {
    orderRepository.save(order);
    outboxRepository.save(new OutboxEvent("OrderCreated", order.id()));
}
    </code></pre>
            <p>Then a separate process reads the outbox and publishes the events</p>
        </section>

        <section>
            <h3>Trivial Publisher</h3>
            <pre><code data-trim>
while (true) {
    for (OutboxEvent event : outboxRepository.findUnpublished()) {
        eventBus.publish(event.toDomainEvent());
        event.markAsPublished();
    }
}
    </code></pre>
            <p>Reliable, asynchronous, and decoupled event publishing.</p>
        </section>

        <section>
            <h2>Change Data Capture (CDC)</h2>
            <p>Instead of polling the outbox table manually...</p>
            <p>We can let the database <strong>stream its own changes</strong>.</p>
        </section>

        <section>
            <h3>CDC in Action</h3>
            <ul>
                <li>Tools like <strong>Debezium</strong> rely on db replication protocols</li>
                <li>Each committed change becomes an event</li>
                <li>No need to modify application logic</li>
            </ul>
            <pre><code data-trim>
-- Database change -->
INSERT INTO outbox (...) VALUES (...)

-- Debezium -->
Produces Kafka event: OrderCreated { orderId: 42 }
    </code></pre>
        </section>

        <section>
            <h3>Outbox + CDC Combo</h3>
            <p><strong>Most robust solution:</strong></p>
            <ul>
                <li>Use the <strong>outbox table</strong> for atomic writes</li>
                <li>Use <strong>CDC</strong> to stream events out automatically</li>
                <li>No dual writes, no lost events, no external transactions</li>
            </ul>
        </section>

        <section>
            <h3>Trade-offs</h3>
            <ul>
                <li>Increased complexity (extra tables/processes)</li>
                <li>Possible duplication ‚Üí requires idempotency</li>
            </ul>
        </section>

        <section>
            <h2>Distributed Transactions</h2>
            <p>When one business operation spans multiple services or databases.</p>
            <ul>
                <li>Each service has its own local data and transaction boundaries.</li>
                <li>We still want <strong>atomicity</strong> across them.</li>
            </ul>
            <p class="fragment">But... there‚Äôs no global transaction manager in distributed systems.</p>
        </section>

        <section>
            <h3>Example</h3>
            <p>Booking a trip:</p>
            <ul>
                <li>Reserve a flight ‚úàÔ∏è</li>
                <li>Book a hotel üè®</li>
                <li>Charge a credit card üí≥</li>
            </ul>
            <p class="fragment">If one step fails, the others must be reverted.</p>
        </section>

        <section>
            <h2>Two-Phase Commit (2PC)</h2>
            <p>Classic protocol to coordinate distributed commits.</p>
            <ol>
                <li><strong>Prepare phase</strong> - coordinator asks all participants if they can commit.</li>
                <li><strong>Commit phase</strong> - if all say ‚Äúyes‚Äù, everyone commits; otherwise, all roll back.</li>
            </ol>
        </section>

        <section>
            <h3>2PC Pros and Cons</h3>
            <ul>
                <li>‚úÖ Guarantees atomicity across systems.</li>
                <li>‚ùå Introduces a single point of failure ‚Äì the coordinator.</li>
                <li>‚ùå Participants must lock data until the commit is decided.</li>
                <li>‚ùå Doesn‚Äôt scale well under high latency or partial failures.</li>
            </ul>
        </section>

        <section>
            <h3>When 2PC Fails</h3>
            <p>If the coordinator crashes between phases...</p>
            <ul>
                <li>Some participants may have committed.</li>
                <li>Others may still be waiting.</li>
                <li>System enters an <strong>uncertain state</strong>.</li>
            </ul>
            <p class="fragment">Recovery requires manual intervention or a timeout heuristic.</p>
        </section>

        <section>
            <h2>The Saga Pattern</h2>
            <p>An alternative to distributed transactions.</p>
            <ul>
                <li>Each step is a <strong>local transaction</strong>.</li>
                <li>On failure, execute <strong>compensating actions</strong>.</li>
            </ul>
        </section>

        <section>
            <h3>Two Saga Coordination Styles</h3>
            <ul>
                <li><strong>Choreography</strong> - services react to each other's events.</li>
                <li><strong>Orchestration</strong> - a central orchestrator tells each participant what to do.</li>
            </ul>
            <p class="fragment">Both achieve eventual consistency, but with different trade-offs.</p>
        </section>

        <section>
            <h3>Saga Example</h3>
            <pre><code data-trim style="font-size: 0.8em;line-height:1.1;">
BookTripSaga:
  1. FlightService.reserve(flight)
  2. HotelService.book(hotel)
  3. PaymentService.charge(user)

If step 3 fails:
  -> HotelService.cancelBooking()
  -> FlightService.releaseSeat()
  </code></pre>
        </section>

        <section>
            <h2>Transaction Isolation</h2>
            <p>Even inside a single database, transactions can interfere with each other.</p>
            <p>Isolation defines <strong>how visible</strong> one transaction‚Äôs changes are to others.</p>
            <br>
            <small><small>Remember PACELC?</small></small>
        </section>

        <section>
            <h3>ACID Refresher</h3>
            <ul>
                <li><strong>A</strong>tomicity - all or nothing</li>
                <li><strong>C</strong>onsistency - valid state transitions</li>
                <li><strong>I</strong>solation - no interference</li>
                <li><strong>D</strong>urability - once committed, it stays</li>
            </ul>
        </section>

        <section>
            <h2>Why Isolation Matters</h2>
            <p>Concurrent transactions may cause anomalies:</p>
            <ul>
                <li><strong>Dirty Read</strong> - see uncommitted data</li>
                <li><strong>Non-repeatable Read</strong> - unexpected data changes</li>
                <li><strong>Phantom Read</strong> - new rows appear unexpectedly</li>
                <li><strong>Lost Update</strong> - two transactions overwrite each other</li>
            </ul>
        </section>

        <section>
            <h3>Dirty Read Example</h3>
            <pre><code data-trim>
T1: UPDATE accounts SET balance = balance - 100 WHERE id=1;
T2: SELECT balance FROM accounts WHERE id=1; -- sees uncommitted value
T1: ROLLBACK;
    </code></pre>
            <p><em>T2 read something that never really existed.</em></p>
        </section>

        <section>
            <h3>Non-Repeatable Read Example</h3>
            <pre><code data-trim>
T1: SELECT * FROM orders WHERE id = 1; -- sees "status = NEW"
T2: UPDATE orders SET status = 'PAID' WHERE id = 1; COMMIT;
T1: SELECT * FROM orders WHERE id = 1; -- sees "status = PAID"
    </code></pre>
            <p><em>Same query, different result - during one transaction.</em></p>
        </section>

        <section>
            <h3>Phantom Read Example</h3>
            <pre><code data-trim>
T1: SELECT * FROM orders WHERE status = 'NEW'; -- returns 3 rows
T2: INSERT INTO orders (status) VALUES ('NEW'); COMMIT;
T1: SELECT * FROM orders WHERE status = 'NEW'; -- now 4 rows
    </code></pre>
            <p><em>New ‚Äúphantom‚Äù data appears mid-transaction.</em></p>
        </section>

        <section>
            <h2>Write Skew Anomaly</h2>
            <p>Occurs when two concurrent transactions read overlapping data and make <strong>non-conflicting writes</strong> based on those reads.</p>
            <p>Even though each transaction is consistent on its own, the <em>combined result</em> breaks an invariant.</p>
        </section>

        <section>
            <h3>Classic Example</h3>
            <p>Hospital rule: <strong>at least one doctor must be on call</strong>.</p>
            <pre><code data-trim style="font-size:0.85em">
CREATE TABLE doctors (
    id INT,
    on_call BOOLEAN
);
-- Initially:
-- Dr. Alice: on_call = true
-- Dr. Bob:   on_call = true
    </code></pre>
        </section>

        <section>
            <h3>Step 1 - Two Transactions Start</h3>
            <pre><code data-trim>
T1: SELECT * FROM doctors WHERE on_call = true;
-- sees Alice + Bob

T2: SELECT * FROM doctors WHERE on_call = true;
-- sees Alice + Bob
    </code></pre>
            <p>Both see that someone else is on call.</p>
        </section>

        <section>
            <h3>Step 2 - Both Decide to Go Off Call</h3>
            <pre><code data-trim>
T1: UPDATE doctors SET on_call = false WHERE name = 'Alice';
T2: UPDATE doctors SET on_call = false WHERE name = 'Bob';
    </code></pre>
            <p>Each assumes the other doctor stays on call.</p>
        </section>

        <section>
            <h3>Step 3 - Both Commit</h3>
            <pre><code data-trim>
T1: COMMIT;
T2: COMMIT;
    </code></pre>
            <p><strong>Invariant broken:</strong> nobody is on call anymore üö®</p>
        </section>

        <section>
            <h3>Why It Happens</h3>
            <ul>
                <li>Both transactions read the same initial state</li>
                <li>Each makes a decision that was valid at that moment</li>
                <li>No direct conflict ‚Üí no locking ‚Üí no blocking</li>
                <li>Combined result violates a business rule</li>
            </ul>
        </section>

        <section>
            <h3>Isolation Levels and Write Skew</h3>
            <table style="font-size:0.9em">
                <thead>
                <tr>
                    <th>Isolation Level</th>
                    <th>Prevents Write Skew?</th>
                </tr>
                </thead>
                <tbody>
                <tr><td>Read Committed</td><td>‚ùå</td></tr>
                <tr><td>Repeatable Read</td><td>‚ùå (in most DBs)</td></tr>
                <tr><td>Serializable</td><td>‚úÖ</td></tr>
                </tbody>
            </table>
            <p><small>Only Serializable prevents it, e.g. via predicate locks or SSI (Serializable Snapshot Isolation).</small></p>
        </section>


        <section>
            <h2>Serializable ‚â† Simple</h2>
            <p>Serializable isolation <strong>simulates sequential execution</strong>.</p>
            <p>But it comes at a cost:</p>
            <ul>
                <li>Higher contention and locking</li>
                <li>Deadlocks</li>
                <li>Lower throughput</li>
            </ul>
        </section>



        <section>
            <blockquote>
                Using common sense is the ultimate Best Practice‚Ñ¢.
            </blockquote>
        </section>
        <section>
            <h2>Thank You!</h2>
            <h5>Need help? Reach out! It's free.</h5>

            <br><br><br><br>
            <h4><a href="https://twitter.com/pivovarit">@pivovarit</a></h4>
            <small><a href="https://4comprehension.com">4comprehension.com</a></small>
            <br>
        </section>
    </div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });
</script>
</body>
<style>
    .footer {
        position: fixed;
        bottom: 0;
        width: 98%;
        color: black;
        text-align: right;
        padding: 10px 0px;
        font-size: 60%;
    }
</style>
</html>
