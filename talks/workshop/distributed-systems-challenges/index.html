<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/simple.css">

    <link rel="stylesheet" href="plugin/highlight/zenburn.css">
</head>
<body>
<div class="reveal">
    <div class="footer"><a href="http://twitter.com/pivovarit">@pivovarit</a></div>

    <div class="slides">
        <section>
            <h3>Challenges of Distributed Systems</h3>
            <br><br>
            <h4><a href="https://pivovarit.github.io"> Grzegorz Piwowarek</a></h4>
            <h5><a href="https://twitter.com/pivovarit">@pivovarit</a></h5>
        </section>

        <section>
            <h2>{ <a href="https://4comprehension.com/">4comprehension.com</a> }</h2>
            <h4>WarsawJUG | Vavr | Oracle ACE</h4>
            <h4>Independent Consultant/Trainer</h4>
            <small>distributed systems | microservices | async | reactive | java</small>
            <h5><a href="https://twitter.com/pivovarit">@pivovarit</a></h5>
            <br>
        </section>

        <section>
            <h2>What makes systems...distributed?</h2>
        </section>

        <section>
            <h2>CAP Theorem</h2>
            <ul>
                <li><strong>C</strong>onsistency</li>
                <li><strong>A</strong>vailability</li>
                <li><strong>P</strong>artition tolerance</li>
            </ul>
        </section>

        <section>
            <h2>Consistency</h2>
            <h5>every read receives the most recent write</h5>
            <small>(a single-copy illusion)</small>
        </section>

        <section>
            <h2>Availability</h2>
            <h5>every request receives a non-error response</h5>
            <small>(even if some nodes are down)</small>
        </section>

        <section>
            <h2>Partition tolerance</h2>
            <h5>system continues to operate even if network links are lost</h5>
        </section>

        <section>
            <h4>distributed systems are systems that communicate over unreliable channels</h4>
        </section>

        <section>
            <p><strong>Rule:</strong> In the presence of a network partition, a distributed system must choose either
                <em>Consistency</em> or <em>Availability</em>.</p>
        </section>

        <section>
            <h3>...</h3>
        </section>

        <section>
            <img src="img/snake.jpg" width="70%"/>
        </section>

        <section data-transition="fade">
            <img src="img/microservices.jpeg" width="80%"/>
            <small><small><a href="https://twitter.com/ddprrt/status/1425418538257428488">https://twitter.com/ddprrt/status/1425418538257428488</a></small></small>
        </section>

        <section data-transition="fade">
            <img src="img/microservices-2.jpeg" width="80%"/>
            <small><small><a href="https://twitter.com/ddprrt/status/1425418538257428488">https://twitter.com/ddprrt/status/1425418538257428488</a></small></small>
        </section>

        <section>
            <img src="img/hoare.jpg" width="30%"/>
            <blockquote
                    cite="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">
                "It was the invention of the null reference in 1965...I call it my billion-dollar mistake."
            </blockquote>
            <small><small>Tony Hoare</small></small>
        </section>

        <section>
            <img src="img/future-null.jpg" width="60%"/>
        </section>


        <section data-transition="fade">
            <h4>Another <em>"billion-dollar mistake":</em></h4>
            <h3 class="fragment">Microservices</h3>
        </section>

        <section data-transition="fade">
            <h4>Another <em>"billion-dollar mistake":</em></h4>
            <h3>"Micro"</h3>
        </section>

        <section data-transition="fade">
            <h4 class="fragment">Microservice vs service?</h4>
            <h4 class="fragment">How small is "micro"?</h4>
            <h5 class="fragment">N lines of code?</h5>
            <h5 class="fragment">N endpoints?</h5>
            <h5 class="fragment">N classes?</h5>
            <h5 class="fragment">N MBs?</h5>
            <h5 class="fragment">N responsibilities?</h5>
            <h5 class="fragment">Rewritable in X time?</h5>
        </section>

        <section>
            <h4>Microservices: the Main Idea</h4>
            <h3 class="fragment">Enable scalability through independence and modularity</h3>
        </section>

        <section data-transition="fade">
            <h4>Tight coupling - Low cohesion</h4>

            <img src="img/tight-coupling.png" width="50%"/>
            <br>
            <small><small>source: <a href="https://enterprisecraftsmanship.com/posts/cohesion-coupling-difference/">https://enterprisecraftsmanship.com/posts/cohesion-coupling-difference/</a></small></small>
        </section>
        <section data-transition="fade">
            <h4>Low coupling - High cohesion</h4>

            <img src="img/loose-coupling.png" width="50%"/>
            <br>
            <small><small>source: <a href="https://enterprisecraftsmanship.com/posts/cohesion-coupling-difference/">https://enterprisecraftsmanship.com/posts/cohesion-coupling-difference/</a></small></small>
        </section>

        <section>
            <h4>You can have modularity without microservices</h4>
            <img class="fragment" src="img/modular.png" width="50%"/>
            <small class="fragment">Naturally, you don't get all the benefits, but it's not a demanding
                investment</small>
        </section>

        <section>
            <img src="img/evolution.png" width="70%"/>
        </section>

        <section>
            <blockquote cite="Building Microservices by Sam Newman">
                "The smaller the service, the more you maximize the benefits and downsides of microservice
                architecture."
            </blockquote>
            <small>Sam Newman</small>
        </section>

        <section>
            <img src="img/netflix.png" width="70%"/>
            <br>
            <small>author: Bruce Wong</small>
            <h3 class="fragment">Netflix: 2000 engineers</h3>
        </section>

        <section>
            <img src="img/boat.png" width="50%"/>
        </section>

        <section>
            <blockquote cite="'How Netflix Really Uses Java' by Paul Bakker" width="100%">
                However, don't be fooled by the size of those microservices, because a lot of those so-called
                microservices at Netflix are a lot larger, just looking at the code base, than the big monoliths that
                I've worked at, at many other companies.
            </blockquote>
            <small>Paul Bakker</small>
            <br>
            <small><small>source: <a href="https://www.infoq.com/presentations/netflix-java/">https://www.infoq.com/presentations/netflix-java/</a></small></small>
        </section>

        <section>
            <h5>Do not ask about the max size, but when to split</h5>
        </section>

        <section>
            <h5>So... when do we split?</h5>
            <br>
            <h5 class="fragment">When it hurts too much</h5>
            <h5 class="fragment">The #1 rule of distributed systems: don't do it until you have to</h5>
        </section>

        <section>
            <img src="img/micro-monolith.jpg" width="70%"/>
        </section>


        <section>
            <h3>The Pragmatic Default</h3>
            <img src="img/citadel.png" width="60%"/>
            <br>
            <small> <small><a href="https://twitter.com/dhh/status/1247522358908215296</small">https://twitter.com/dhh/status/1247522358908215296</a></small></small>
        </section>

        <section>
            <blockquote cite="'Static Analysis at Scale: An Instagram Story' by Benjamin Woodruff" width="100%">
                Our server app is a monolith, one big codebase of several million lines and a few thousand Django
                endpoints [1], all loaded up and served together. A few services have been split out of the monolith,
                but we don‚Äôt have any plans to aggressively break it up.
            </blockquote>
            <small><small><a
                    href="https://instagram-engineering.com/static-analysis-at-scale-an-instagram-story-8f498ab71a0c">https://instagram-engineering.com/static-analysis-at-scale-an-instagram-story-8f498ab71a0c</a></small></small>
        </section>

        <section>
            <h4>Reliability in an unreliable world</h4>
        </section>

        <section>
            <h4>When sending a message over unreliable channels, how to guarantee delivery?</h4>
        </section>

        <section>
            <h4>(...thought experiment...)</h4>
        </section>

        <section>
            <h3>Definition</h3>
            <p>An operation is <strong>idempotent</strong> if performing it multiple times produces the <em>same
                effect</em> as performing it once.</p>
            <br>
            <pre><code>f(f(x)) = f(x)</code></pre>
        </section>

        <section>
            <h3>Examples</h3>
            <ul>
                <li>Setting a user‚Äôs status to ‚Äúactive‚Äù ‚Üí ‚úÖ</li>
                <li>Incrementing a counter ‚Üí ‚ùå</li>
            </ul>
        </section>

        <section>
            <h3>In a distributed system</h3>
            <p>Failures and retries are inevitable.</p>
        </section>

        <section>
            <ul>
                <li>Network retries may cause duplicate requests</li>
                <li>Clients or load balancers might resend operations</li>
                <li>Idempotency prevents unwanted side effects</li>
            </ul>
        </section>


        <section>
            <h3>Exactly-once delivery?</h3>
            <p><strong>A fairy tale.</strong></p>
            <br><br>
            <div class="fragment">
                <p><strong>Reality:</strong> You only ever get:</p>
                <ul>
                    <li><strong>at-most-once</strong> ‚Üí messages may be lost</li>
                    <li><strong>at-least-once</strong> ‚Üí messages may be duplicated</li>
                </ul>
            </div>
        </section>

        <section>
            <h3>Exactly-once doesn‚Äôt exist</h3>
            <ul>
                <li>Networks can fail between <em>send</em> and <em>acknowledge</em></li>
                <li>Clients can retry</li>
                <li>Servers can crash mid-processing</li>
            </ul>
        </section>

        <section>
            <h3>Exactly-once <em>effect</em></h3>
            <p>We can‚Äôt guarantee <em>exactly-once delivery</em>,</p>
            <p>but we can design for <strong>exactly-once effect</strong> using idempotency.</p>
            <br>
            <pre><code>at-least-once delivery + idempotency = exactly-once</code></pre>
        </section>

        <section>
            <h2>PACELC Theorem</h2>
            <p>
                Daniel Abadi extended CAP to include trade-offs <em>when no partition occurs</em>:
            </p>
            <blockquote>
                <strong>If P</strong> (partition) ‚Üí <em>A</em> or <em>C</em><br>
                <strong>Else</strong> (ok) ‚Üí <em>Latency</em> or <em>Consistency</em>
            </blockquote>
        </section>

        <section>
            <p>Even without partitions, there‚Äôs another trade-off</p>
            <strong>Waiting for consensus takes time</strong>
            <br><br>
            <small><p>This is the ‚ÄúELC‚Äù part of PACELC.</p></small>
        </section>

        <section>
            <h3>Imagine two coffee shops sharing an order system</h3>
            <ul>
                <li>network failure</strong> ‚Üí choice:
                    <em>keep taking orders (A)</em> or <em>pause until synced (C)</em></li>
                <li>no failure</strong> ‚Üí each order can be:
                    <em>fast but maybe outdated (L)</em> or <em>slow but always accurate (C)</em></li>
            </ul>
        </section>

        <section>
            <h3>Real-world examples</h3>
            <ul>
                <li><strong>Amazon Dynamo / Cassandra</strong> ‚Üí prioritize <em>Availability + Low Latency</em></li>
                <li><strong>Google Spanner</strong> ‚Üí prioritize <em>Consistency</em>, accept more latency</li>
            </ul>
        </section>

        <section>
            <h3>temporal coupling</h3>
            <h4>when all your services need to responsive at the same time</h4>
        </section>

        <section>
            <h3>False Dichotomy:</h3>
            <h4>Consistent vs. Inconsistent</h4>
        </section>

        <section>
            <h3>Different consistency levels</h3>
            <ul>
                <li><strong>Strong consistency</strong> ‚Üí Data converges immediately</li>
                <li><strong>Eventual consistency</strong> ‚Üí Data converges... eventually</li>
                <li><strong>Accidental consistency</strong> ‚Üí Data converges... maybe</li>
            </ul>
            <p>All are ‚Äúconsistent‚Äù ‚Äî just in different ways.</p>
        </section>

        <section>
            <h3>Eventual consistency</h3>
            <blockquote>
                If no new updates occur, all replicas will <strong>eventually</strong> converge to the same state.
            </blockquote>
            <p>It‚Äôs a trade-off: we get <strong>availability and speed</strong> at the cost of temporary disagreement.
            </p>
        </section>

        <section>
            <h3>Why this makes sense</h3>
            <ul>
                <li>Networks are slow and unreliable</li>
                <li>Waiting for everyone to agree slows everything down</li>
                <li>So we let nodes respond now and sync later</li>
            </ul>
            <p>‚Üí <strong>Fast now, consistent later</strong></p>
        </section>

        <section data-transition="fade">
            <h3>synchronous communication</h3>
            <img src="img/sync1.png" width="80%"/>
        </section>

        <section data-transition="fade">
            <h3>asynchronous communication</h3>
            <img src="img/sync2.png" width="80%"/>
        </section>

        <section>
            <h3>From HTTP calls...</h3>
            <pre><code data-trim>
OrderService -> PaymentService -> NotificationService
    </code></pre>
            <p>Each service calls another directly...</p>
            <p><em>...tight coupling, dependencies, and failure chains.</em></p>
        </section>

        <section>
            <h3>...to Events</h3>
            <pre><code data-trim>
OrderService --> publishes OrderCreatedEvent
PaymentService --> consumes OrderCreatedEvent
NotificationService --> consumes PaymentConfirmedEvent
    </code></pre>
            <p>Services react to <strong>events</strong> instead of making direct calls.</p>
        </section>

        <section>
            <h2>Local Read Models</h2>
            <p>Each service maintains its own <strong>local view</strong> of data it needs.</p>
            <pre><code data-trim>
@EventListener
void on(PaymentConfirmedEvent event) {
    orderReadModel.updateStatus(event.orderId(), "PAID");
}
    </code></pre>
            <p>This enables fast, local reads - no cross-service queries needed</p>
            <p>...but it eventually consistent</p>

        </section>

        <section>
            <h3>Why Local Read Models?</h3>
            <ul>
                <li>No need to call other services for data</li>
                <li>Improves reliability - service can operate even if others are down</li>
            </ul>
        </section>


        <section>
            <h2>Time</h2>

            <img src="img/time.jpg" width="60%"/>
        </section>

        <section>
            <pre><code data-trim="" style="font-size: 0.8em;line-height: 0.9; max-height: 90%">
                   var first = Instant.now();
                   var second = Instant.now();
            </code></pre>

            <h3><code>first</code> <= <code>second?</code></h3>
        </section>

        <section>
            <p>A <strong>monotonic clock</strong> always moves forward - never backward.</p>
            <p>But most <code>system clocks</code> are <strong>not monotonic</strong>.</p>
        </section>

        <section>
            <h3>Why clocks go backwards</h3>
            <ul>
                <li><strong>NTP</strong> (Network Time Protocol) adjustment</li>
                <li>Virtual machines paused and resumed</li>
                <li>Leap seconds</li>
                <li>Manual time correction by an admin</li>
            </ul>
        </section>

        <section>
            <h3>Monotonic clocks to the rescue</h3>
            <ul>
                <li>In Java: <code>System.nanoTime()</code></li>
                <li>In Linux: <code>CLOCK_MONOTONIC</code></li>
            </ul>
            <p>They never go backward, but don‚Äôt represent ‚Äúreal‚Äù time.</p>

            <br>
            <small><a href="https://www.javaadvent.com/2019/12/measuring-time-from-java-to-kernel-and-back.html">Measuring time: from Java to kernel and back</a></small>

        </section>

        <section>
            <p>In distributed systems, time is‚Ä¶ <strong>an illusion</strong>.</p>
        </section>

        <section>
            <h3>The problem with clocks</h3>
            <ul>
                <li>Each machine has its own clock</li>
                <li>Clocks drift - even if synced</li>
                <li>Network delays make ‚Äúnow‚Äù ambiguous</li>
            </ul>
            <p>So: there is no single, global ‚Äúcurrent time.‚Äù</p>
        </section>

        <section>
            <h3>Example</h3>
            <p>Two servers record an event:</p>
            <ul>
                <li>Server A: event at 12:00:00.100</li>
                <li>Server B: event at 12:00:00.090</li>
            </ul>
            <p>Which happened first? ü§î</p>
        </section>

        <section>
            <h3>Why this matters</h3>
            <ul>
                <li>Event ordering affects state changes</li>
                <li>Conflicts appear when we can‚Äôt tell ‚Äúwhat came first‚Äù</li>
                <li>Replication, logs, and causality all depend on time</li>
            </ul>
        </section>

        <section>
            <h3>Happened-before relationship</h3>
            <p>Instead of wall-clock time, we use <strong>causal order</strong>:</p>
            <blockquote>
                A ‚Üí B if A happened before B (causally)
            </blockquote>
            <p>We care about <em>ordering</em> of events, not their timestamps.</p>
        </section>

        <section>
            <h3>Logical clocks</h3>
            <ul>
                <li><strong>Lamport clocks</strong> ‚Üí simple counters to track causal order</li>
                <li><strong>Vector clocks</strong> ‚Üí richer structure to detect concurrent events</li>
            </ul>
            <p>They don‚Äôt measure real time - they measure <strong>cause and effect</strong>.</p>
        </section>

        <section>
            <h3>Real time vs. logical time</h3>
            <ul>
                <li><strong>Real time</strong> ‚Üí what your watch shows</li>
                <li><strong>Logical time</strong> ‚Üí what the system can <em>prove</em> happened first</li>
            </ul>
            <p>Distributed systems live in <strong>logical time</strong>.</p>
        </section>

        <section>
            <p>Google‚Äôs Spanner uses special hardware clocks (TrueTime API) ‚è±Ô∏è</p>
            <p>But even then, they include an <strong>uncertainty window</strong> - because perfect time doesn‚Äôt exist.
            </p>
        </section>

        <section>
            <h3>Summary</h3>
            <ul>
                <li>Each node has its own imperfect sense of time</li>
                <li>We can‚Äôt rely on timestamps for ordering</li>
                <li>We use <strong>logical or causal time</strong> to reason safely</li>
            </ul>
            <p>Time is relative - especially in distributed systems üåå</p>
        </section>

        <section>
            <h5>Eventual Consistency != Accidental Consistency</h5>
        </section>

        <section data-transition="fade">
            <img src="img/dual-write.png" width="60%"/>
        </section>

        <section data-transition="fade">
            <img src="img/dual-write-2.png" width="60%"/>
        </section>

        <section>

            <pre><code class="hljs language-java" data-trim data-noescape>
                @Transactional
                public void createUser(CreateUserCommand command) {
                    var user = from(command);

                    persist(user);                     // 1
                    send(UserCreatedEvent.from(user)); // 2
                }
            </code></pre>
            <h4><code>@Transactional</code> won't save you in the distributed world</h4>
        </section>

        <section data-transition="fade">
            <h4>Dual-Write (distributed transaction)</h4>
            <img src="img/cdc3.png" width="50%"/>
        </section>

        <section data-transition="fade">
            <h4>Singe-Write with async propagation</h4>
            <img src="img/cdc4.png" width="50%"/>
        </section>

        <section>
            <h4>Transactional Outbox Pattern</h4>
            <h4>Change Data Capture</h4>
        </section>

        <section>
            <blockquote>
                Using common sense is the ultimate Best Practice‚Ñ¢.
            </blockquote>
        </section>
        <section>
            <h2>Thank You!</h2>
            <h5>Need help? Reach out! It's free.</h5>

            <br><br><br><br>
            <h4><a href="https://twitter.com/pivovarit">@pivovarit</a></h4>
            <small><a href="https://4comprehension.com">4comprehension.com</a></small>
            <br>
        </section>
    </div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });
</script>
</body>
<style>
    .footer {
        position: fixed;
        bottom: 0;
        width: 98%;
        color: black;
        text-align: right;
        padding: 10px 0px;
        font-size: 60%;
    }
</style>
</html>
